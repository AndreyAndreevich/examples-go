// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package domain

import (
	"database/sql/driver"
	"errors"
	"fmt"
)

const (
	// LimitTypeMINAMOUNT is a LimitType of type MIN_AMOUNT.
	LimitTypeMINAMOUNT LimitType = iota
	// LimitTypeMAXAMOUNT is a LimitType of type MAX_AMOUNT.
	LimitTypeMAXAMOUNT
	// LimitTypeTOTALAMOUNT is a LimitType of type TOTAL_AMOUNT.
	LimitTypeTOTALAMOUNT
	// LimitTypeTOTALCOUNT is a LimitType of type TOTAL_COUNT.
	LimitTypeTOTALCOUNT
)

var ErrInvalidLimitType = errors.New("not a valid LimitType")

const _LimitTypeName = "min_amountmax_amounttotal_amounttotal_count"

var _LimitTypeMap = map[LimitType]string{
	LimitTypeMINAMOUNT:   _LimitTypeName[0:10],
	LimitTypeMAXAMOUNT:   _LimitTypeName[10:20],
	LimitTypeTOTALAMOUNT: _LimitTypeName[20:32],
	LimitTypeTOTALCOUNT:  _LimitTypeName[32:43],
}

// String implements the Stringer interface.
func (x LimitType) String() string {
	if str, ok := _LimitTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("LimitType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LimitType) IsValid() bool {
	_, ok := _LimitTypeMap[x]
	return ok
}

var _LimitTypeValue = map[string]LimitType{
	_LimitTypeName[0:10]:  LimitTypeMINAMOUNT,
	_LimitTypeName[10:20]: LimitTypeMAXAMOUNT,
	_LimitTypeName[20:32]: LimitTypeTOTALAMOUNT,
	_LimitTypeName[32:43]: LimitTypeTOTALCOUNT,
}

// ParseLimitType attempts to convert a string to a LimitType.
func ParseLimitType(name string) (LimitType, error) {
	if x, ok := _LimitTypeValue[name]; ok {
		return x, nil
	}
	return LimitType(0), fmt.Errorf("%s is %w", name, ErrInvalidLimitType)
}

// MarshalText implements the text marshaller method.
func (x LimitType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LimitType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseLimitType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errLimitTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LimitType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LimitType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = LimitType(v)
	case string:
		*x, err = ParseLimitType(v)
	case []byte:
		*x, err = ParseLimitType(string(v))
	case LimitType:
		*x = v
	case int:
		*x = LimitType(v)
	case *LimitType:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = *v
	case uint:
		*x = LimitType(v)
	case uint64:
		*x = LimitType(v)
	case *int:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = LimitType(*v)
	case *int64:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = LimitType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = LimitType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = LimitType(*v)
	case *uint:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = LimitType(*v)
	case *uint64:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x = LimitType(*v)
	case *string:
		if v == nil {
			return errLimitTypeNilPtr
		}
		*x, err = ParseLimitType(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x LimitType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// PeriodTypeCALENDARDAY is a PeriodType of type CALENDAR_DAY.
	PeriodTypeCALENDARDAY PeriodType = iota
	// PeriodTypeCALENDARWEEK is a PeriodType of type CALENDAR_WEEK.
	PeriodTypeCALENDARWEEK
	// PeriodTypeCALENDARMONTH is a PeriodType of type CALENDAR_MONTH.
	PeriodTypeCALENDARMONTH
)

var ErrInvalidPeriodType = errors.New("not a valid PeriodType")

const _PeriodTypeName = "calendar_daycalendar_weekcalendar_month"

var _PeriodTypeMap = map[PeriodType]string{
	PeriodTypeCALENDARDAY:   _PeriodTypeName[0:12],
	PeriodTypeCALENDARWEEK:  _PeriodTypeName[12:25],
	PeriodTypeCALENDARMONTH: _PeriodTypeName[25:39],
}

// String implements the Stringer interface.
func (x PeriodType) String() string {
	if str, ok := _PeriodTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PeriodType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PeriodType) IsValid() bool {
	_, ok := _PeriodTypeMap[x]
	return ok
}

var _PeriodTypeValue = map[string]PeriodType{
	_PeriodTypeName[0:12]:  PeriodTypeCALENDARDAY,
	_PeriodTypeName[12:25]: PeriodTypeCALENDARWEEK,
	_PeriodTypeName[25:39]: PeriodTypeCALENDARMONTH,
}

// ParsePeriodType attempts to convert a string to a PeriodType.
func ParsePeriodType(name string) (PeriodType, error) {
	if x, ok := _PeriodTypeValue[name]; ok {
		return x, nil
	}
	return PeriodType(0), fmt.Errorf("%s is %w", name, ErrInvalidPeriodType)
}

// MarshalText implements the text marshaller method.
func (x PeriodType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PeriodType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePeriodType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errPeriodTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *PeriodType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = PeriodType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = PeriodType(v)
	case string:
		*x, err = ParsePeriodType(v)
	case []byte:
		*x, err = ParsePeriodType(string(v))
	case PeriodType:
		*x = v
	case int:
		*x = PeriodType(v)
	case *PeriodType:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = *v
	case uint:
		*x = PeriodType(v)
	case uint64:
		*x = PeriodType(v)
	case *int:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = PeriodType(*v)
	case *int64:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = PeriodType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = PeriodType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = PeriodType(*v)
	case *uint:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = PeriodType(*v)
	case *uint64:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x = PeriodType(*v)
	case *string:
		if v == nil {
			return errPeriodTypeNilPtr
		}
		*x, err = ParsePeriodType(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x PeriodType) Value() (driver.Value, error) {
	return x.String(), nil
}
